/**
 * IOTA Client for interacting with StudyStake smart contract
 * Uses IOTA Move blockchain with dapp-kit Transaction builder
 */

import { IotaClient } from '@iota/iota.js/client'
import { Transaction } from '@iota/iota.js/transactions'
import { getWalletData } from './storage'

// IOTA Network Configuration
const IOTA_RPC_URL = process.env.NEXT_PUBLIC_IOTA_RPC_URL || 'https://api.testnet.iota.cafe'
const PACKAGE_ID = process.env.NEXT_PUBLIC_CONTRACT_PACKAGE_ID!
const TASK_REGISTRY_ID = process.env.NEXT_PUBLIC_TASK_REGISTRY_ID!

// Initialize IOTA client
const client = new IotaClient({ url: IOTA_RPC_URL })

/**
 * Get IOTA client instance
 */
export function getIotaClient(): IotaClient {
  return client
}

/**
 * Convert IOTA to NANOS (smallest unit)
 * 1 IOTA = 1,000,000,000 NANOS
 */
function iotaToNanos(iota: number): string {
  return Math.floor(iota * 1_000_000_000).toString()
}

/**
 * Create a transaction for staking a task
 * Returns the Transaction object to be signed by dapp-kit
 */
export function createStakeTaskTransaction(
  taskId: string,
  stakeAmount: number,
  charityAddress: string
): Transaction {
  const tx = new Transaction()

  // Split coins for the stake amount
  const stakeAmountNanos = iotaToNanos(stakeAmount)
  const [coin] = tx.splitCoins(tx.gas, [tx.pure(stakeAmountNanos, 'u64')])

  // Call smart contract stake_task function
  tx.moveCall({
    target: `${PACKAGE_ID}::studystake::stake_task`,
    arguments: [
      tx.object(TASK_REGISTRY_ID), // TaskRegistry shared object
      tx.pure(taskId, 'string'),   // task_id
      coin,                         // stake: Coin<IOTA>
      tx.pure(charityAddress, 'address'), // charity_address
    ],
  })

  return tx
}

/**
 * Create a transaction for completing a task
 * Returns the Transaction object to be signed by dapp-kit
 */
export function createCompleteTaskTransaction(taskId: string): Transaction {
  const tx = new Transaction()

  // Call smart contract complete_task function
  tx.moveCall({
    target: `${PACKAGE_ID}::studystake::complete_task`,
    arguments: [
      tx.object(TASK_REGISTRY_ID), // TaskRegistry shared object
      tx.pure(taskId, 'string'),   // task_id
    ],
  })

  return tx
}

/**
 * Create a transaction for forfeiting a task
 * Returns the Transaction object to be signed by dapp-kit
 */
export function createForfeitTaskTransaction(taskId: string): Transaction {
  const tx = new Transaction()

  // Call smart contract forfeit_task function
  tx.moveCall({
    target: `${PACKAGE_ID}::studystake::forfeit_task`,
    arguments: [
      tx.object(TASK_REGISTRY_ID), // TaskRegistry shared object
      tx.pure(taskId, 'string'),   // task_id
    ],
  })

  return tx
}

/**
 * Legacy function wrappers for backward compatibility
 * These return transaction objects instead of executing directly
 */
export async function stakeTask(
  taskId: string,
  stakeAmount: number,
  charityAddress: string
): Promise<Transaction> {
  return createStakeTaskTransaction(taskId, stakeAmount, charityAddress)
}

export async function completeTask(taskId: string): Promise<Transaction> {
  return createCompleteTaskTransaction(taskId)
}

export async function forfeitTask(taskId: string): Promise<Transaction> {
  return createForfeitTaskTransaction(taskId)
}

/**
 * Get task details from the blockchain
 */
export async function getTaskDetails(taskObjectId: string): Promise<any> {
  try {
    const object = await client.getObject({
      id: taskObjectId,
      options: {
        showContent: true,
        showOwner: true,
      },
    })

    return object.data
  } catch (error) {
    console.error('Error fetching task details:', error)
    throw new Error(`Failed to fetch task: ${error instanceof Error ? error.message : 'Unknown error'}`)
  }
}

/**
 * Get user's IOTA balance
 */
export async function getBalance(address: string): Promise<number> {
  try {
    const balance = await client.getBalance({
      owner: address,
    })

    // Convert from NANOS to IOTA
    return Number(balance.totalBalance) / 1_000_000_000
  } catch (error) {
    console.error('Error fetching balance:', error)
    return 0
  }
}

/**
 * Query events from the smart contract
 */
export async function queryEvents(eventType: string, limit: number = 10): Promise<any[]> {
  try {
    const events = await client.queryEvents({
      query: {
        MoveEventType: `${PACKAGE_ID}::studystake::${eventType}`,
      },
      limit,
      order: 'descending',
    })

    return events.data || []
  } catch (error) {
    console.error('Error querying events:', error)
    return []
  }
}

/**
 * Format transaction details for display
 */
export function formatTransactionDetails(
  type: 'stake' | 'complete' | 'forfeit',
  taskName: string,
  stakeAmount?: number,
  charityName?: string
): Array<{ label: string; value: string }> {
  const details = [
    { label: 'Action', value: type.charAt(0).toUpperCase() + type.slice(1) + ' Task' },
    { label: 'Task', value: taskName },
  ]

  if (type === 'stake' && stakeAmount) {
    details.push({ label: 'Stake Amount', value: `${stakeAmount} IOTA` })
    if (charityName) {
      details.push({ label: 'Charity', value: charityName })
    }
  }

  return details
}
